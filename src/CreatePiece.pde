import ddf.minim.*;
import ddf.minim.ugens.*;

/*************************************************************
 * Produces a musical piece given the spatial relationship   *
 * between points in the Lorenz system generated by given    *
 * values for the parameters sigma, beta and rho.            *  
 *                                                           *
 * Version: 12/07/2016                                       *
 * Author: Chaitanya Varier                                  *
 *************************************************************
 */
 
// Constants
public static final float maxDistAbs = 36.58579521112, maxDistAdj = 5.58550240224;
public static final float minDistAbs = 2.64733390459, minDistAdj = 0.02311542086;
  
public static final float attracX1 = -8.358359191, attracY1 = -8.41142473, attracZ1 = 26.87020614;
public static final float attracX2 = 8.281888215, attracY2 = 8.508647967, attracZ2 = 27.11247407;
public static final float attracXM = (attracX1 + attracX2)/2, attracYM = (attracY1 + attracY2)/2, attracZM = (attracZ1 + attracZ2)/2;
// 1000 pts in 16.747 s
public static final int tempo = (int) (1000/16.747 * 60);

public static final int maxPoints = 6001;

/* Frequency increases as distAbs decreases
   minFreq = maxFreq - deltaFreq=> deltaFreq is the amplitude of the frequency multiplier function */
public static final float maxFreq = 1300, deltaFreq = 1200;
/* Amplitude increases as distAdj decreases
   minAmp = maxAmp - deltaAmp => deltaAmp is the amplitude of the amplitude multiplier function */
public static final float maxAmp = 1.0, deltaAmp = 0.9;

// Objects
Minim minim;
AudioOutput out;
AudioRecorder recorder;
MoogFilter moog;

BufferedReader readerX, readerY, readerZ;

PVector[] vecs = new PVector[6001];
public static int iter = 0;

// to make an Instrument we must define a class
// that implements the Instrument interface.
class SineInstrument implements Instrument
{
  
  Oscil wave;
  Line  ampEnv;
  
  SineInstrument(float frequency, float amplitude)
  {
    // make a sine wave oscillator
    // the amplitude is zero because 
    // we are going to patch a Line to it anyway
    wave = new Oscil(frequency, amplitude, Waves.SINE);
    //ampEnv = new Line();
    //ampEnv.patch(wave.amplitude);
  }
  
  // this is called by the sequencer when this instrument
  // should start making sound. the duration is expressed in seconds.
  void noteOn(float duration)
  {
    
    // start the amplitude envelope
    //ampEnv.activate(duration, 0.5f, 0);
    // attach the oscil to the output so it makes sound
    wave.patch(out);
    
  }
  
  // this is called by the sequencer when the instrument should
  // stop making sound
  void noteOff()
  {
    
    wave.unpatch(out);
    
  }
  
}

void setup()
{
  
  // Read points from text files into PVector arrayList
  readerX = createReader("LPoints10_0-2_66-28_0X.txt");
  readerY = createReader("LPoints10_0-2_66-28_0Y.txt");
  readerZ = createReader("LPoints10_0-2_66-28_0Z.txt");
  
  for (int i = 0; i < vecs.length; i++) {
    
    try {
      
      vecs[i] = new PVector(Float.parseFloat(readerX.readLine()), Float.parseFloat(readerY.readLine()), 
        Float.parseFloat(readerZ.readLine()));
      
    } catch (IOException e) {
      
      e.printStackTrace();
      
    }
    
  }
  
  size(512, 200, P3D);
  
  minim = new Minim(this);
  
  // use the getLineOut method of the Minim object to get an AudioOutput object
  out = minim.getLineOut(Minim.STEREO);
  
  // construct a low pass MoogFilter with a 
  // cutoff frequency of 100 Hz and a resonance of 0.5
  moog = new MoogFilter( 100, 0.0 );
  moog.type = MoogFilter.Type.HP;
  
  // Create recorder
  recorder = minim.createRecorder(out, "Lorenz10_0-2_66-28_0.wav");
  recorder.beginRecord();
  
  // Pause needed for sequencer to work.
  out.pauseNotes();
      
  // Set current tempo in beats/min
  out.setTempo(tempo);
  
  // Create piece
  for (int i = 0; i < vecs.length - 1; i++) {
   
    float distAdj = (float) Math.sqrt((vecs[i + 1].x - vecs[i].x) * (vecs[i + 1].x - vecs[i].x)
                              + (vecs[i + 1].y - vecs[i].y) * (vecs[i + 1].y - vecs[i].y)
                              + (vecs[i + 1].z - vecs[i].z) * (vecs[i + 1].z - vecs[i].z));
    
    float distAbs = (float) Math.sqrt((vecs[i].x - attracXM) * (vecs[i].x - attracXM)
                              + (vecs[i].y - attracYM) * (vecs[i].y - attracYM)
                              + (vecs[i].z - attracZM) * (vecs[i].z - attracZM));
    
    /* Calculate current tempo based on distance between two adjacent points:
       The first factor is the tempo multiplier function */
       
    float curAmp = maxAmp - ((distAdj - minDistAdj) / (maxDistAdj - minDistAdj)) * deltaAmp;
    
    /* Calculate current tempo based on distance between two adjacent points:
       The first factor is the frequency multiplier function */
    float curFreq = maxFreq - (distAbs - minDistAbs) / (maxDistAbs - minDistAbs) * deltaFreq; 
    
    /* Set current note
       Params: start time (beats), duration (beats), (frequency (Hz), amplitude) */
    out.playNote(i, 1.0, new SineInstrument(curFreq, curAmp));
    
  }
  
  // now we can start the sequencer again to hear our sequence
  out.resumeNotes();
  
}

void draw()
{
  
  background(0);
  stroke(255);
  
  // draw the waveforms
  for(int i = 0; i < out.bufferSize() - 1; i++)
  {
    line( i, 50 + out.left.get(i)*50, i+1, 50 + out.left.get(i+1)*50 );
    line( i, 150 + out.right.get(i)*50, i+1, 150 + out.right.get(i+1)*50 );
  }
  
} //<>//

void keyReleased()
{
  if ( key == 's' )
  {
    // we've filled the file out buffer, 
    // now write it to the file we specified in createRecorder
    // in the case of buffered recording, if the buffer is large, 
    // this will appear to freeze the sketch for sometime
    // in the case of streamed recording, 
    // it will not freeze as the data is already in the file and all that is being done
    // is closing the file.
    // the method returns the recorded audio as an AudioRecording, 
    // see the example  AudioRecorder >> RecordAndPlayback for more about that
    recorder.save();
    println("Done saving.");
  }
}